
## 链表：

### 链表特征：
* 无法随机访问，只能通过遍历找到特定元素
* 编历循环时，要关注每一个节点指针的位置，避免漏操作
* 用例往往存在链表为空的特殊情况，此时按通常情况操作head->next会报错，这里有个技巧：在可能为空的链表前添加前置节点。
```cpp
ListNode *tmpHead = new ListNode();       // 此时tmpHead为前置节点
ListNode *ans = tmpHead;
while(1){
...
	tmpHead->next = new ListNode();       // 保证tmpHead->next一定有效
	tmpHead=tmpHead->next;
...
}
return ans->next;                         // 返回前置节点的下一个节点
```

### 例题：
#### 141.环形链表：
思路：从头遍历，访问到重复节点，意味着存在环结构
* 元素个数 ≤ 10000，可以用哈希表（unordered_set）记录节点的访问情况
 
#### 2.两数相加
思路：由于是倒序，遍历会从低位开始访问，则遍历并顺序相加即可
* 需注意进位情况，可能存在新增最高位的情况

#### 21. 合并两个有序链表
思路：暴力写法，是同时遍历两个链表，将较小元素添加到新链表中，最终生成一个有序的新链表；不过原体本意是想避免创建新节点，而仅对老节点排列组合
* 这里重地关注下递归解法：

> [!NOTE] 链表中的递归
> 

